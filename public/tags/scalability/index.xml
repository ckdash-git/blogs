<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Scalability on Chandan Kumar Dash</title>
        <link>http://localhost:1313/tags/scalability/</link>
        <description>Recent content in Scalability on Chandan Kumar Dash</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 08 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/scalability/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>Load Balancing: The Traffic Cop of Distributed Systems</title>
            <link>http://localhost:1313/blogs/system-design/load-balancing/</link>
            <pubDate>Sun, 08 Feb 2026 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/blogs/system-design/load-balancing/</guid>
            <description>&lt;p&gt;When you have multiple servers (Horizontal Scaling), you need a way to distribute traffic among them. Enter the &lt;strong&gt;Load Balancer (LB)&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;A Load Balancer acts as the entry point to your system. It accepts requests from clients and routes them to the appropriate backend server.&lt;/p&gt;&#xA;&lt;h2 id=&#34;core-concepts&#34;&gt;Core Concepts&#xA;&lt;/h2&gt;&lt;h3 id=&#34;1-virtual-ip-vip&#34;&gt;1. Virtual IP (VIP)&#xA;&lt;/h3&gt;&lt;p&gt;Clients don&amp;rsquo;t talk to individual servers (IP1, IP2). They talk to the &lt;strong&gt;VIP&lt;/strong&gt; of the Load Balancer. The LB then forwards the request internally.&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-health-checks&#34;&gt;2. Health Checks&#xA;&lt;/h3&gt;&lt;p&gt;The LB constantly pings your servers (&amp;ldquo;Are you alive?&amp;rdquo;). If a server crashes, the LB stops sending traffic to it. This ensures &lt;strong&gt;High Availability&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-high-availability-ha-for-the-lb-itself&#34;&gt;3. High Availability (HA) for the LB itself&#xA;&lt;/h3&gt;&lt;p&gt;If the LB crashes, your whole site goes down. To prevent this, we use &lt;strong&gt;Redundancy&lt;/strong&gt; (Active-Passive LB setup).&lt;/p&gt;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;&#xA;  %%{init: {&amp;#39;theme&amp;#39;: &amp;#39;dark&amp;#39;}}%%&#xA;graph TD&#xA;    Client --&amp;gt; VIP[Virtual IP]&#xA;    VIP --&amp;gt; LB1[Active LB]&#xA;    VIP -.-&amp;gt; LB2[Passive LB]&#xA;    &#xA;    LB1 --&amp;gt; S1[Server 1]&#xA;    LB1 --&amp;gt; S2[Server 2]&#xA;    LB1 --&amp;gt; S3[Server 3]&#xA;    &#xA;    style LB1 fill:#99ff99,stroke:#333&#xA;    style LB2 fill:#ff9999,stroke:#333&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;load-balancing-algorithms&#34;&gt;Load Balancing Algorithms&#xA;&lt;/h2&gt;&lt;p&gt;How does the LB decide which server gets the next request?&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Algorithm&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Description&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Use Case&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Round Robin&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Cyclic order (S1 -&amp;gt; S2 -&amp;gt; S3 -&amp;gt; S1). Simple.&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Servers with equal specs.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Weighted Round Robin&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Assigns more requests to powerful servers.&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Heterogeneous fleet (some big, some small servers).&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Least Connections&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Sends to the server with fewest active connections.&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Long-lived connections (e.g., WebSocket, Chat).&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Least Response Time&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Sends to the fastest responding server.&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Performance-sensitive apps.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;IP Hash&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Hashes Client IP to map to a specific server.&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Session Stickiness&lt;/strong&gt; (Ensure User A always goes to Server 1).&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;timeline-of-a-request&#34;&gt;Timeline of a Request&#xA;&lt;/h2&gt;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Client&lt;/strong&gt; sends request to &lt;code&gt;api.example.com&lt;/code&gt; (VIP).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LB&lt;/strong&gt; receives request.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LB&lt;/strong&gt; checks &lt;strong&gt;Health Status&lt;/strong&gt; of backend pool.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LB&lt;/strong&gt; selects a server using an &lt;strong&gt;Algorithm&lt;/strong&gt; (e.g., Round Robin).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LB&lt;/strong&gt; forwards request to &lt;code&gt;Server 2&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Server 2&lt;/code&gt; processes and responds.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&#xA;&lt;/h2&gt;&lt;p&gt;Load Balancers are essential for scaling. They provide:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Scalability&lt;/strong&gt;: Add servers seamlessly.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Availability&lt;/strong&gt;: Automatically bypass dead servers.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Flexibility&lt;/strong&gt;: Perform maintenance on servers without downtime.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;However, remember that the LB itself can be a bottleneck or a single point of failure if not configured with redundancy.&lt;/p&gt;&#xA;</description>
        </item><item>
            <title>Scalability: Vertical vs Horizontal Scaling</title>
            <link>http://localhost:1313/blogs/system-design/scalability/</link>
            <pubDate>Sun, 08 Feb 2026 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/blogs/system-design/scalability/</guid>
            <description>&lt;p&gt;When your app goes viral, your server will crash. To fix this, you have two choices:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Make your existing server stronger (&lt;strong&gt;Vertical Scaling&lt;/strong&gt;).&lt;/li&gt;&#xA;&lt;li&gt;Add more servers to share the load (&lt;strong&gt;Horizontal Scaling&lt;/strong&gt;).&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;what-is-scalability&#34;&gt;What is Scalability?&#xA;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Scalability&lt;/strong&gt; is a system&amp;rsquo;s ability to handle an increased load without degraded performance.&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-vertical-scaling-scale-up&#34;&gt;1. Vertical Scaling (Scale Up)&#xA;&lt;/h2&gt;&lt;p&gt;You upgrade the existing machine. You add more RAM, a faster CPU, or a bigger SSD.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Analogy&lt;/strong&gt;: Your car is too slow, so you replace the engine with a Ferrari engine. It&amp;rsquo;s still one car, but much faster.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Pros&lt;/strong&gt;: Simple. No code changes required. Lower management overhead.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Cons&lt;/strong&gt;: Expensive. Has a hard limit (you can&amp;rsquo;t upgrade forever). &lt;strong&gt;Single Point of Failure&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;&#xA;  %%{init: {&amp;#39;theme&amp;#39;: &amp;#39;dark&amp;#39;}}%%&#xA;graph TD&#xA;    User --&amp;gt; Server[Small Server]&#xA;    Server --&amp;gt;|Upgrade| BigServer[BIG Server]&#xA;    style BigServer fill:#ff9900,stroke:#333,stroke-width:4px&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;2-horizontal-scaling-scale-out&#34;&gt;2. Horizontal Scaling (Scale Out)&#xA;&lt;/h2&gt;&lt;p&gt;You add more machines to your pool of resources.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Analogy&lt;/strong&gt;: Your car can&amp;rsquo;t carry enough people, so you buy a second car (and a third, and a fourth).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Pros&lt;/strong&gt;: Infinite scaling. Cheaper hardware. &lt;strong&gt;High Availability&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Cons&lt;/strong&gt;: Complex. Requires Load Balancers. Data consistency challenges.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;&#xA;  %%{init: {&amp;#39;theme&amp;#39;: &amp;#39;dark&amp;#39;}}%%&#xA;graph TD&#xA;    User --&amp;gt; LB[Load Balancer]&#xA;    LB --&amp;gt; S1[Server 1]&#xA;    LB --&amp;gt; S2[Server 2]&#xA;    LB --&amp;gt; S3[Server 3]&#xA;    style LB fill:#f9f,stroke:#333&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;comparisons&#34;&gt;Comparisons&#xA;&lt;/h2&gt;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Feature&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Vertical Scaling (Scale Up)&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Horizontal Scaling (Scale Out)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Complexity&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Low (Easy)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;High (Hard)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Cost&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;High (Premium Hardware)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Low (Commodity Hardware)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Limit&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Hard Hardware Limit&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Theoretically Unlimited&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Failover&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Single Point of Failure&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Resilient (Redundancy)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Downtime&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Required for upgrades&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Zero downtime upgrades&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&#xA;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;Start with &lt;strong&gt;Vertical Scaling&lt;/strong&gt; for simplicity (Monoliths).&lt;/li&gt;&#xA;&lt;li&gt;Switch to &lt;strong&gt;Horizontal Scaling&lt;/strong&gt; when you need reliability and massive scale (Distributed Systems).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
        </item><item>
            <title>Distributed Systems: Definition, Advantages, and Challenges</title>
            <link>http://localhost:1313/blogs/system-design/distributed-systems/</link>
            <pubDate>Sat, 07 Feb 2026 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/blogs/system-design/distributed-systems/</guid>
            <description>&lt;p&gt;In the previous post, we explored &lt;a class=&#34;link&#34; href=&#34;http://localhost:1313/blogs/understanding-monolithic-architecture-the-all-in-one-approach/&#34; &gt;Monolithic Architecture&lt;/a&gt;, where everything lives in one big box. While simple, monoliths struggle to scale beyond a certain point.&lt;/p&gt;&#xA;&lt;p&gt;Enter &lt;strong&gt;Distributed Systems&lt;/strong&gt;—the architecture that powers the modern internet. From Google Search to Netflix, distributed systems are what allow applications to handle millions of concurrent users without crashing.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-a-distributed-system&#34;&gt;What is a Distributed System?&#xA;&lt;/h2&gt;&lt;p&gt;A &lt;strong&gt;Distributed System&lt;/strong&gt; is a collection of independent computers that appear to its users as a single coherent system.&lt;/p&gt;&#xA;&lt;p&gt;Instead of one massive server doing everything, you have multiple machines (nodes) communicating over a network to achieve a common goal.&lt;/p&gt;&#xA;&lt;h3 id=&#34;monolithic-vs-distributed&#34;&gt;Monolithic vs. Distributed&#xA;&lt;/h3&gt;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Feature&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Monolithic System&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Distributed System&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Deployment&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Single server/location&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Multiple machines across networks&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Scaling&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Vertical (Add more RAM/CPU to one machine)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Horizontal (Add more machines)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Failure&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Single Point of Failure (If server dies, app dies)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Fault Tolerant (If one node dies, others take over)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Complexity&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Low&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;High&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;key-advantages&#34;&gt;Key Advantages&#xA;&lt;/h2&gt;&lt;h3 id=&#34;1-fault-tolerance-no-single-point-of-failure&#34;&gt;1. Fault Tolerance (No Single Point of Failure)&#xA;&lt;/h3&gt;&lt;p&gt;In a monolith, if the server crashes, your business stops. In a distributed system, data and services are &lt;strong&gt;replicated&lt;/strong&gt; across multiple machines.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Real-Life Example&lt;/strong&gt;: If one Google data center goes offline due to a power outage, your search query is simply routed to another data center. You don&amp;rsquo;t even notice the failure.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-horizontal-scalability&#34;&gt;2. Horizontal Scalability&#xA;&lt;/h3&gt;&lt;p&gt;This is the superpower of distributed systems.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Vertical Scaling (Monolith)&lt;/strong&gt;: Upgrading a server is like buying a bigger truck. Eventually, you can&amp;rsquo;t buy a bigger truck.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Horizontal Scaling (Distributed)&lt;/strong&gt;: Simply buy &lt;em&gt;more&lt;/em&gt; trucks. You can add cheap, commodity hardware to the cluster to handle increased load endlessly.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-low-latency-geo-distribution&#34;&gt;3. Low Latency (Geo-Distribution)&#xA;&lt;/h3&gt;&lt;p&gt;You can place servers closer to your users.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Real-Life Example&lt;/strong&gt;: &lt;strong&gt;Netflix&lt;/strong&gt;. When you stream a movie, you aren&amp;rsquo;t downloading it from Netflix HQ in California. You are streaming it from an Open Connect appliance (CDN) located at your local ISP&amp;rsquo;s data center, ensuring instant buffering.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;challenges-the-price-of-power&#34;&gt;Challenges: The Price of Power&#xA;&lt;/h2&gt;&lt;p&gt;Distributed systems are powerful, but they are hard to build and manage.&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-data-consistency&#34;&gt;1. Data Consistency&#xA;&lt;/h3&gt;&lt;p&gt;If you have data on five different machines, how do you ensure they all agree?&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Scenario&lt;/strong&gt;: User A updates their profile picture on Node 1. User B views the profile on Node 2. If replication is slow, User B sees the old photo. This is the classic &lt;strong&gt;Consistency vs. Availability&lt;/strong&gt; trade-off (CAP Theorem).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-network-unreliability&#34;&gt;2. Network Unreliability&#xA;&lt;/h3&gt;&lt;p&gt;Calls within a monolith are instant function calls. Calls in a distributed system go over a network. Networks are unreliable—packets get lost, latency spikes, and connections drop.&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-operational-complexity&#34;&gt;3. Operational Complexity&#xA;&lt;/h3&gt;&lt;p&gt;Managing one server is easy. Managing a fleet of 1,000 servers requires sophisticated tools for:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Orchestration&lt;/strong&gt; (Kubernetes)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Monitoring&lt;/strong&gt; (Prometheus, Grafana)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Logging&lt;/strong&gt; (ELK Stack)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;real-life-example-google-search&#34;&gt;Real-Life Example: Google Search&#xA;&lt;/h2&gt;&lt;p&gt;Google Search is the ultimate distributed system.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Crawling&lt;/strong&gt;: Thousands of machines crawl the web in parallel.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Indexing&lt;/strong&gt;: The index is too large for one computer, so it&amp;rsquo;s &lt;strong&gt;sharded&lt;/strong&gt; across thousands of machines.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Searching&lt;/strong&gt;: When you type a query, it&amp;rsquo;s sent to hundreds of machines that search their specific shard of the index in parallel. The results are then aggregated and returned to you in milliseconds.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&#xA;&lt;/h2&gt;&lt;p&gt;Distributed Systems are the answer to &amp;ldquo;How do we scale big?&amp;rdquo; They offer resilience and infinite scaling but introduce significant complexity in data management and operations. For most startups, a Monolith is the right start. For a global enterprise, a Distributed System is a necessity.&lt;/p&gt;&#xA;</description>
        </item><item>
            <title>Introduction to System Design: Concepts, Process, and Types</title>
            <link>http://localhost:1313/blogs/system-design/introduction-to-system-design/</link>
            <pubDate>Sat, 07 Feb 2026 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/blogs/system-design/introduction-to-system-design/</guid>
            <description>&lt;p&gt;System Design is one of the most critical skills for software engineers, especially as they progress to senior roles. It’s the process of defining the architecture, modules, interfaces, and data for a system to satisfy specified requirements.&lt;/p&gt;&#xA;&lt;p&gt;In simple terms, if coding is about &lt;em&gt;how&lt;/em&gt; to write a function, System Design is about &lt;em&gt;where&lt;/em&gt; that function lives, how it talks to other parts of the application, and how the entire system scales to handle millions of users.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-system-design&#34;&gt;What is System Design?&#xA;&lt;/h2&gt;&lt;p&gt;System Design is the process of defining the elements of a system—such as architecture, modules, and components—and their interfaces and data for a system to satisfy specified requirements. It is the bridge between a problem statement and the final code.&lt;/p&gt;&#xA;&lt;p&gt;The main objective is to &lt;strong&gt;define and organize the elements&lt;/strong&gt; of an application to ensure that all parts work cohesively. A well-designed system is:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Scalable&lt;/strong&gt;: Can handle growth in users and data.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Reliable&lt;/strong&gt;: Functions correctly even when components fail.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Maintainable&lt;/strong&gt;: Easy to understand and modify.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;types-of-system-design&#34;&gt;Types of System Design&#xA;&lt;/h2&gt;&lt;p&gt;In the context of software engineering, System Design is generally categorized into two main types: &lt;strong&gt;High-Level Design (HLD)&lt;/strong&gt; and &lt;strong&gt;Low-Level Design (LLD)&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-high-level-design-hld&#34;&gt;1. High-Level Design (HLD)&#xA;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&amp;ldquo;The Big Picture&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;HLD focuses on the overall system architecture. It identifies the major components of the system and how they interact with each other. It answers questions like:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&amp;ldquo;Microservices or Monolith?&amp;rdquo;&lt;/li&gt;&#xA;&lt;li&gt;&amp;ldquo;SQL or NoSQL?&amp;rdquo;&lt;/li&gt;&#xA;&lt;li&gt;&amp;ldquo;How do we handle caching?&amp;rdquo;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Real-Life Example: Designing Uber (HLD)&lt;/strong&gt;&#xA;When designing the HLD for Uber, you wouldn&amp;rsquo;t worry about the specific class for a &lt;code&gt;Driver&lt;/code&gt;. Instead, you&amp;rsquo;d define:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Load Balancers&lt;/strong&gt; to distribute traffic.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Microservices&lt;/strong&gt; for User Management, Ride Matching, and Payments.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Database&lt;/strong&gt; choices (e.g., PostgreSQL for transactions, Cassandra for location history).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Communication Protocols&lt;/strong&gt; (e.g., WebSockets for real-time location updates).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-low-level-design-lld&#34;&gt;2. Low-Level Design (LLD)&#xA;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&amp;ldquo;The Detailed View&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;LLD dives into the implementation details of the components defined in the HLD. It focuses on the internal logic of modules, data structures, algorithms, and class diagrams.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Real-Life Example: Designing the &lt;code&gt;RideMatching&lt;/code&gt; Service (LLD)&lt;/strong&gt;&#xA;Continuing with the Uber example, LLD would define:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Class Diagrams&lt;/strong&gt;: A &lt;code&gt;Driver&lt;/code&gt; class, a &lt;code&gt;Rider&lt;/code&gt; class, and a &lt;code&gt;Trip&lt;/code&gt; class.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Interfaces&lt;/strong&gt;: Public methods like &lt;code&gt;findNearestDriver(location)&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Database Schema&lt;/strong&gt;: The exact columns in the &lt;code&gt;Trips&lt;/code&gt; table.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Algorithms&lt;/strong&gt;: The specific logic used to match a rider with a driver (e.g., using a QuadTree for geospatial search).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;the-system-design-process&#34;&gt;The System Design Process&#xA;&lt;/h2&gt;&lt;p&gt;Designing a system is not a linear process, but it generally follows a structured flow:&lt;/p&gt;&#xA;&lt;h3 id=&#34;step-1-requirements-gathering&#34;&gt;Step 1: Requirements Gathering&#xA;&lt;/h3&gt;&lt;p&gt;Before drawing any diagrams, you must understand what you are building.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Functional Requirements&lt;/strong&gt;: What should the system do? (e.g., &amp;ldquo;Users can post tweets&amp;rdquo;).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Non-Functional Requirements&lt;/strong&gt;: How should the system behave? (e.g., &amp;ldquo;The system must be highly available&amp;rdquo;).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;step-2-define-architecture-hld&#34;&gt;Step 2: Define Architecture (HLD)&#xA;&lt;/h3&gt;&lt;p&gt;Decide on the high-level structure.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Monolith vs. Microservices&lt;/strong&gt;: Choose based on team size and complexity.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Data Flow&lt;/strong&gt;: How does data move from the user to the database?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;step-3-identify-modules&#34;&gt;Step 3: Identify Modules&#xA;&lt;/h3&gt;&lt;p&gt;Break the system down into smaller, manageable chunks.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;For an E-commerce site: Inventory Service, User Service, Cart Service, Order Service.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;step-4-define-interaction-points&#34;&gt;Step 4: Define Interaction Points&#xA;&lt;/h3&gt;&lt;p&gt;Specify how these modules will communicate.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Synchronous&lt;/strong&gt;: REST API or gRPC.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Asynchronous&lt;/strong&gt;: Message Queues (Kafka, RabbitMQ).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;step-5-data-modeling-and-logic-lld&#34;&gt;Step 5: Data Modeling and Logic (LLD)&#xA;&lt;/h3&gt;&lt;p&gt;Define the database schema and business logic.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Schema Design&lt;/strong&gt;: Tables, relationships, and indexes.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;API Design&lt;/strong&gt;: Define the endpoints (e.g., &lt;code&gt;POST /api/v1/checkout&lt;/code&gt;).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;summary&#34;&gt;Summary&#xA;&lt;/h2&gt;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Feature&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;High-Level Design (HLD)&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Low-Level Design (LLD)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Focus&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Overall Architecture&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Component Implementation&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Audience&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Architects, Stakeholders&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Developers&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Deliverables&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;System Diagrams, Tech Stack&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Class Diagrams, DB Schema&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&amp;ldquo;Use Redis for caching&amp;rdquo;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&amp;ldquo;Use &lt;code&gt;LRUCache&lt;/code&gt; class with &lt;code&gt;HashMap&lt;/code&gt;&amp;rdquo;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&#xA;&lt;/h2&gt;&lt;p&gt;System Design is finding the optimal solution to a problem under constraints. Whether you are building a small startup app or a global platform like Netflix, understanding the distinction between HLD and LLD and following a structured design process is key to success.&lt;/p&gt;&#xA;&lt;p&gt;Stay tuned for more deep dives into specific System Design components like &lt;strong&gt;Load Balancing&lt;/strong&gt;, &lt;strong&gt;Caching strategies&lt;/strong&gt;, and &lt;strong&gt;Database Sharding&lt;/strong&gt;!&lt;/p&gt;&#xA;</description>
        </item></channel>
</rss>
