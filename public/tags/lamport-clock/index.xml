<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Lamport Clock on Chandan Kumar Dash</title>
        <link>http://localhost:1313/tags/lamport-clock/</link>
        <description>Recent content in Lamport Clock on Chandan Kumar Dash</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 08 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/lamport-clock/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>Time in Distributed Systems: Why Clocks Lie</title>
            <link>http://localhost:1313/blogs/system-design/time-in-distributed-systems/</link>
            <pubDate>Sun, 08 Feb 2026 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/blogs/system-design/time-in-distributed-systems/</guid>
            <description>&lt;p&gt;In a Monolithic system, &amp;ldquo;Time&amp;rdquo; is easy. You ask the OS for &lt;code&gt;Date.now()&lt;/code&gt;, and that is the absolute truth.&#xA;In a Distributed System, &amp;ldquo;Time&amp;rdquo; is a nightmare.&lt;/p&gt;&#xA;&lt;p&gt;Common questions like &amp;ldquo;Which event happened first?&amp;rdquo; become remarkably hard to answer.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-problem-with-physical-clocks&#34;&gt;The Problem with Physical Clocks&#xA;&lt;/h2&gt;&lt;p&gt;Distributed systems span different machines, often in different time zones (e.g., US, India, Australia). Each machine has its own &lt;strong&gt;Physical Clock&lt;/strong&gt;.&#xA;Even with NTP (Network Time Protocol), these clocks drift. One server might think it&amp;rsquo;s &lt;code&gt;10:00:00.001&lt;/code&gt; while another thinks it&amp;rsquo;s &lt;code&gt;10:00:00.005&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;This &lt;strong&gt;Clock Skew&lt;/strong&gt; means you cannot rely on timestamps to order events.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Scenario&lt;/strong&gt;: User A books a ticket at &lt;code&gt;10:00:01&lt;/code&gt; (Server US). User B books the same ticket at &lt;code&gt;10:00:02&lt;/code&gt; (Server India). If the India server&amp;rsquo;s clock is 5 seconds slow, it might record the time as &lt;code&gt;09:59:57&lt;/code&gt;, making it look like User B booked it first!&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;ideally-partial-ordering&#34;&gt;Ideally: Partial Ordering&#xA;&lt;/h2&gt;&lt;p&gt;We don&amp;rsquo;t need to know the &lt;em&gt;exact&lt;/em&gt; time. We just need to know the &lt;strong&gt;Order of Events&lt;/strong&gt;.&#xA;This is called the &lt;strong&gt;Happened-Before Relationship&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-solution-lamport-logical-clocks&#34;&gt;The Solution: Lamport Logical Clocks&#xA;&lt;/h2&gt;&lt;p&gt;Leslie Lamport introduced a simple algorithm to solve this using &lt;strong&gt;Logical Counters&lt;/strong&gt; instead of real time.&lt;/p&gt;&#xA;&lt;h3 id=&#34;the-algorithm&#34;&gt;The Algorithm&#xA;&lt;/h3&gt;&lt;p&gt;Every process maintains a counter &lt;code&gt;C&lt;/code&gt;, initially &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Internal Event&lt;/strong&gt;: Before executing an event, increment &lt;code&gt;C = C + 1&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Send Message&lt;/strong&gt;: Increment &lt;code&gt;C = C + 1&lt;/code&gt; and send &lt;code&gt;C&lt;/code&gt; along with the message.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Receive Message&lt;/strong&gt;: When receiving a message with counter &lt;code&gt;C_msg&lt;/code&gt;, update your local counter: &lt;code&gt;C = max(C, C_msg) + 1&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;visualizing-the-flow&#34;&gt;Visualizing the Flow&#xA;&lt;/h3&gt;&lt;p&gt;Let&amp;rsquo;s look at three processes (P1, P2, P3) interacting. Notice how P2&amp;rsquo;s clock jumps forward when it receives a message from P3.&lt;/p&gt;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;&#xA;  %%{init: {&amp;#39;theme&amp;#39;: &amp;#39;dark&amp;#39;}}%%&#xA;sequenceDiagram&#xA;    participant P1&#xA;    participant P2&#xA;    participant P3&#xA;    &#xA;    Note over P1,P3: Initial State: All Clocks = 0&#xA;    &#xA;    P1-&amp;gt;&amp;gt;P1: Event A (C=1)&#xA;    P2-&amp;gt;&amp;gt;P2: Event B (C=1)&#xA;    &#xA;    P1-&amp;gt;&amp;gt;P2: Message (C=2)&#xA;    Note right of P2: P2 receives C=2.&amp;lt;br/&amp;gt;max(1, 2) + 1 = 3&#xA;    P2-&amp;gt;&amp;gt;P2: Event C (C=3)&#xA;    &#xA;    P3-&amp;gt;&amp;gt;P3: Event D (C=1)&#xA;    P3-&amp;gt;&amp;gt;P2: Message (C=2)&#xA;    Note right of P2: P2 receives C=2.&amp;lt;br/&amp;gt;max(3, 2) + 1 = 4&#xA;    P2-&amp;gt;&amp;gt;P2: Event E (C=4)&#xA;    &#xA;    P2-&amp;gt;&amp;gt;P1: Message (C=5)&#xA;    Note left of P1: P1 receives C=5.&amp;lt;br/&amp;gt;max(1, 5) + 1 = 6&#xA;    P1-&amp;gt;&amp;gt;P1: Event F (C=6)&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;what-this-tells-us&#34;&gt;What This Tells Us&#xA;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;If event &lt;code&gt;A&lt;/code&gt; caused event &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;Clock(A) &amp;lt; Clock(B)&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;This gives us a &lt;strong&gt;Partial Ordering&lt;/strong&gt; of events.&lt;/li&gt;&#xA;&lt;li&gt;It does &lt;strong&gt;not&lt;/strong&gt; give us real time (duration), but it ensures causality is respected.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&#xA;&lt;/h2&gt;&lt;p&gt;In Distributed Systems, &lt;strong&gt;Logical Time &amp;gt; Physical Time&lt;/strong&gt;.&#xA;Tools like &lt;strong&gt;Lamport Clocks&lt;/strong&gt; and &lt;strong&gt;Vector Clocks&lt;/strong&gt; (an immense improvement on Lamport) are the bedrock of systems like Amazon Dynamo, Cassandra, and Google Spanner. They allow us to agree on the sequence of events without needing atomic clocks in every server.&lt;/p&gt;&#xA;</description>
        </item></channel>
</rss>
